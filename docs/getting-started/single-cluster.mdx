---
title: Single Cluster Installation
description: Deploy OpenChoreo on a single Kubernetes cluster - choose from local development with k3d, quick cloud trial with nip.io, or production with custom domains.
sidebar_position: 1
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import Link from '@docusaurus/Link';
import {versions} from '../_constants.mdx';

# Single Cluster Installation

This guide walks you through installing OpenChoreo on a single Kubernetes cluster. Choose the mode that fits your needs:

| Mode | Best For | Domain | TLS | Cluster |
|------|----------|--------|-----|---------|
| **k3d (Local)** | Local development | `.localhost` | No | k3d |
| **Try Out** | Quick evaluation on cloud | `nip.io` (free) | Yes (Let's Encrypt) | Any Kubernetes |
| **Production** | Production workloads | Custom domain | Yes (required) | Any Kubernetes |

---

## Prerequisites

<Tabs groupId="install-mode" queryString>
<TabItem value="k3d" label="k3d (Local)" default>

**Required tools:**
- **Docker** v26.0+ with at least **8 GB RAM** and **4 CPU** cores allocated
- **[k3d](https://k3d.io/stable/#installation)** v5.8+
- **[kubectl](https://kubernetes.io/docs/tasks/tools/)** v1.32+
- **[Helm](https://helm.sh/docs/intro/install/)** v3.12+

```bash
# Verify prerequisites
docker --version && docker info > /dev/null
k3d --version
kubectl version --client
helm version --short
```

:::note Colima Users
Set `K3D_FIX_DNS=0` when creating clusters to avoid DNS issues. See [k3d-io/k3d#1449](https://github.com/k3d-io/k3d/issues/1449).
:::

</TabItem>
<TabItem value="tryout" label="Try Out">

**Required tools:**
- **[kubectl](https://kubernetes.io/docs/tasks/tools/)** v1.32+ configured to access your cluster
- **[Helm](https://helm.sh/docs/intro/install/)** v3.12+

**Cluster requirements:**
- Kubernetes **1.32+** with at least **3 nodes** (4 CPU, 8GB RAM each)
- LoadBalancer support (cloud provider or MetalLB)
- Public IP accessible from the internet (for Let's Encrypt HTTP-01 validation)

```bash
# Verify prerequisites
kubectl version
helm version --short
kubectl get nodes
```

</TabItem>
<TabItem value="production" label="Production">

**Required tools:**
- **[kubectl](https://kubernetes.io/docs/tasks/tools/)** v1.32+ configured to access your cluster
- **[Helm](https://helm.sh/docs/intro/install/)** v3.12+

**Cluster requirements:**
- Kubernetes **1.32+** with at least **3 nodes** (4 CPU, 8GB RAM each)
- LoadBalancer support (cloud provider or MetalLB)

**You'll also need:**
- A registered domain (e.g., `my-company.com`)
- Access to your DNS provider to create A/CNAME records
- TLS certificates (Let's Encrypt, cloud provider, or bring your own)

```bash
# Verify prerequisites
kubectl version
helm version --short
kubectl get nodes

# Set your base domain (OpenChoreo will be at openchoreo.DOMAIN)
export DOMAIN="my-company.com"
```

</TabItem>
</Tabs>

---

## Step 1: Create Your Kubernetes Cluster

<Tabs groupId="install-mode" queryString>
<TabItem value="k3d" label="k3d (Local)" default>

Create a pre-configured k3d cluster optimized for OpenChoreo:

<CodeBlock language="bash">
{`curl -s https://raw.githubusercontent.com/openchoreo/openchoreo/${versions.githubRef}/install/k3d/single-cluster/config.yaml | k3d cluster create --config=-`}
</CodeBlock>

This creates a cluster named `openchoreo` with:
- 1 server + 2 agent nodes
- Port mappings: Control Plane (8080/8443), Data Plane (9080/9443), Build Plane (10081/10082), Observability (11081/11082)
- kubectl context set to `k3d-openchoreo`

```bash
# Verify cluster is running
kubectl get nodes
```

</TabItem>
<TabItem value="tryout" label="Try Out">

Use your existing Kubernetes cluster. OpenChoreo works with any Kubernetes 1.32+ distribution:

- **Managed**: AKS, EKS, GKE, DigitalOcean, Linode, etc.
- **Self-managed**: kubeadm, Rancher, OpenShift, etc.

```bash
# Verify cluster access and admin permissions
kubectl get nodes
kubectl auth can-i '*' '*' --all-namespaces
```

</TabItem>
<TabItem value="production" label="Production">

Use your existing Kubernetes cluster. OpenChoreo works with any Kubernetes 1.32+ distribution:

- **Managed**: AKS, EKS, GKE, DigitalOcean, Linode, etc.
- **Self-managed**: kubeadm, Rancher, OpenShift, etc.

```bash
# Verify cluster access and admin permissions
kubectl get nodes
kubectl auth can-i '*' '*' --all-namespaces
```

</TabItem>
</Tabs>

---

## Step 2: Configure Domain & TLS

<Tabs groupId="install-mode" queryString>
<TabItem value="k3d" label="k3d (Local)" default>

**No configuration needed!** Local setup uses `.localhost` domains automatically:

| Service | URL |
|---------|-----|
| Console (Backstage) | `http://openchoreo.localhost:8080` |
| API | `http://api.openchoreo.localhost:8080` |
| Deployed Apps | `http://<component>-<env>.openchoreoapis.localhost:9080` |

:::tip
The `.localhost` domain resolves to `127.0.0.1` on most systems without any `/etc/hosts` configuration.
:::

</TabItem>
<TabItem value="tryout" label="Try Out">

Try Out mode uses [nip.io](https://nip.io) for free wildcard DNS based on your LoadBalancer IP.

:::info Two LoadBalancer IPs
OpenChoreo creates two LoadBalancers with different IPs:
- **Control Plane** (Traefik): Console, API, Thunder, Registry
- **Data Plane Gateway** (kgateway): Deployed applications

Since nip.io resolves based on the IP in the hostname, each plane will have its own domain (e.g., `openchoreo.10-20-30-40.nip.io` for control plane and `apps.openchoreo.50-60-70-80.nip.io` for deployed apps).
:::

First, install cert-manager for automatic TLS with Gateway API support:

```bash
helm repo add jetstack https://charts.jetstack.io
helm repo update
helm install cert-manager jetstack/cert-manager \
  --namespace cert-manager --create-namespace \
  --set crds.enabled=true \
  --set config.enableGatewayAPI=true
```

Create Let's Encrypt ClusterIssuers for both the Control Plane (Ingress-based) and Data Plane (Gateway API-based):

```bash
# IMPORTANT: Use YOUR real email address (Let's Encrypt rejects example.com domains)
export EMAIL="your-email@example.com"

# ClusterIssuer for Control Plane (uses Traefik Ingress)
kubectl apply -f - <<EOF
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-prod
spec:
  acme:
    server: https://acme-v02.api.letsencrypt.org/directory
    email: ${EMAIL}
    privateKeySecretRef:
      name: letsencrypt-prod
    solvers:
      - http01:
          ingress:
            ingressClassName: openchoreo-traefik
EOF
```

</TabItem>
<TabItem value="production" label="Production">

Configure TLS certificates for your custom domain. You can use cert-manager with Let's Encrypt, your cloud provider's certificate service, or bring your own certificates.

**Option A: cert-manager with Let's Encrypt**

```bash
helm repo add jetstack https://charts.jetstack.io
helm repo update
helm install cert-manager jetstack/cert-manager \
  --namespace cert-manager --create-namespace \
  --set crds.enabled=true

# Create ClusterIssuer (use YOUR email)
export EMAIL="your-email@example.com"

kubectl apply -f - <<EOF
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-prod
spec:
  acme:
    server: https://acme-v02.api.letsencrypt.org/directory
    email: ${EMAIL}
    privateKeySecretRef:
      name: letsencrypt-prod
    solvers:
      - http01:
          ingress:
            ingressClassName: openchoreo-traefik
EOF
```

**Option B: Bring your own certificates**

Create TLS secrets with your certificates:
```bash
kubectl create secret tls control-plane-tls \
  --cert=path/to/cert.pem --key=path/to/key.pem \
  -n openchoreo-control-plane

kubectl create secret tls data-plane-tls \
  --cert=path/to/cert.pem --key=path/to/key.pem \
  -n openchoreo-data-plane
```

</TabItem>
</Tabs>

---

## Step 3: Install Control Plane

<Tabs groupId="install-mode" queryString>
<TabItem value="k3d" label="k3d (Local)" default>

<CodeBlock language="bash">
{`helm install openchoreo-control-plane oci://ghcr.io/openchoreo/helm-charts/openchoreo-control-plane \\
  --version ${versions.helmChart} \\
  --namespace openchoreo-control-plane \\
  --create-namespace \\
  --values https://raw.githubusercontent.com/openchoreo/openchoreo/${versions.githubRef}/install/k3d/single-cluster/values-cp.yaml`}
</CodeBlock>

</TabItem>
<TabItem value="tryout" label="Try Out">

```bash
# Install with placeholder domain first (to provision LoadBalancer)
helm install openchoreo-control-plane oci://ghcr.io/openchoreo/helm-charts/openchoreo-control-plane \
  --namespace openchoreo-control-plane --create-namespace \
  --set global.baseDomain=placeholder.nip.io \
  --set cert-manager.enabled=false
```

Get the LoadBalancer IP and configure TLS:

```bash
# Wait for LoadBalancer IP (press Ctrl+C once IP appears)
kubectl get svc openchoreo-traefik -n openchoreo-control-plane -w

# Get the IP address and convert to nip.io format (dots to dashes)
LB_IP=$(kubectl get svc openchoreo-traefik -n openchoreo-control-plane \
  -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
# For AWS (uses hostnames): LB_IP=$(dig +short $(kubectl get svc ...) | head -1)

export IP=$(echo $LB_IP | tr '.' '-')
echo "Your base IP: $IP"
echo "Your domain will be: openchoreo.${IP}.nip.io"

# Create TLS certificate
kubectl apply -f - <<EOF
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: control-plane-tls
  namespace: openchoreo-control-plane
spec:
  secretName: control-plane-tls
  issuerRef:
    name: letsencrypt-prod
    kind: ClusterIssuer
  dnsNames:
    - "openchoreo.${IP}.nip.io"
    - "api.openchoreo.${IP}.nip.io"
    - "thunder.openchoreo.${IP}.nip.io"
EOF

# Wait for certificate (should show Ready=True)
kubectl get certificate control-plane-tls -n openchoreo-control-plane -w
```

Upgrade with real domain and TLS:

```bash
helm upgrade openchoreo-control-plane oci://ghcr.io/openchoreo/helm-charts/openchoreo-control-plane \
  --namespace openchoreo-control-plane \
  --set global.baseDomain=openchoreo.${IP}.nip.io \
  --set global.tls.enabled=true \
  --set cert-manager.enabled=false \
  --set "backstage.ingress.tls[0].secretName=control-plane-tls" \
  --set "backstage.ingress.tls[0].hosts[0]=openchoreo.${IP}.nip.io" \
  --set "openchoreoApi.ingress.tls[0].secretName=control-plane-tls" \
  --set "openchoreoApi.ingress.tls[0].hosts[0]=api.openchoreo.${IP}.nip.io" \
  --set "asgardeoThunder.ingress.tls[0].secretName=control-plane-tls" \
  --set "asgardeoThunder.ingress.tls[0].hosts[0]=thunder.openchoreo.${IP}.nip.io"
```

</TabItem>
<TabItem value="production" label="Production">

```bash
helm install openchoreo-control-plane oci://ghcr.io/openchoreo/helm-charts/openchoreo-control-plane \
  --namespace openchoreo-control-plane --create-namespace \
  --set global.baseDomain=openchoreo.${DOMAIN}
```

Configure DNS records pointing to the LoadBalancer:

```bash
# Get LoadBalancer IP/hostname
kubectl get svc openchoreo-traefik -n openchoreo-control-plane -w

# Create these DNS records:
# - openchoreo.${DOMAIN} -> <LoadBalancer IP/hostname>
# - *.openchoreo.${DOMAIN} -> <LoadBalancer IP/hostname>
```

If using cert-manager, create certificates:

```bash
kubectl apply -f - <<EOF
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: control-plane-tls
  namespace: openchoreo-control-plane
spec:
  secretName: control-plane-tls
  issuerRef:
    name: letsencrypt-prod
    kind: ClusterIssuer
  dnsNames:
    - "openchoreo.${DOMAIN}"
    - "api.openchoreo.${DOMAIN}"
    - "thunder.openchoreo.${DOMAIN}"
EOF
```

Enable TLS on ingresses:

```bash
helm upgrade openchoreo-control-plane oci://ghcr.io/openchoreo/helm-charts/openchoreo-control-plane \
  --namespace openchoreo-control-plane \
  --set global.baseDomain=openchoreo.${DOMAIN} \
  --set global.tls.enabled=true \
  --set "backstage.ingress.tls[0].secretName=control-plane-tls" \
  --set "backstage.ingress.tls[0].hosts[0]=openchoreo.${DOMAIN}" \
  --set "openchoreoApi.ingress.tls[0].secretName=control-plane-tls" \
  --set "openchoreoApi.ingress.tls[0].hosts[0]=api.openchoreo.${DOMAIN}" \
  --set "asgardeoThunder.ingress.tls[0].secretName=control-plane-tls" \
  --set "asgardeoThunder.ingress.tls[0].hosts[0]=thunder.openchoreo.${DOMAIN}"
```

</TabItem>
</Tabs>

**Verify Control Plane:**

```bash
kubectl get pods -n openchoreo-control-plane
# Expected: controller-manager, cluster-gateway-*, kgateway-* pods in Running state
```

---

## Step 4: Install Data Plane

The Data Plane uses [Gateway API](https://gateway-api.sigs.k8s.io/) with kgateway for traffic routing. No traditional Ingress controller is needed.

<Tabs groupId="install-mode" queryString>
<TabItem value="k3d" label="k3d (Local)" default>

<CodeBlock language="bash">
{`helm install openchoreo-data-plane oci://ghcr.io/openchoreo/helm-charts/openchoreo-data-plane \\
  --version ${versions.helmChart} \\
  --namespace openchoreo-data-plane \\
  --create-namespace \\
  --values https://raw.githubusercontent.com/openchoreo/openchoreo/${versions.githubRef}/install/k3d/single-cluster/values-dp.yaml`}
</CodeBlock>

Register the data plane with the control plane:

<CodeBlock language="bash">
{`curl -s https://raw.githubusercontent.com/openchoreo/openchoreo/${versions.githubRef}/install/add-data-plane.sh | bash -s -- --control-plane-context k3d-openchoreo --enable-agent --agent-ca-namespace openchoreo-control-plane`}
</CodeBlock>

</TabItem>
<TabItem value="tryout" label="Try Out">

```bash
# Install Data Plane (Gateway API CRDs, kgateway, and GatewayClass are included)
helm install openchoreo-data-plane oci://ghcr.io/openchoreo/helm-charts/openchoreo-data-plane \
  --namespace openchoreo-data-plane --create-namespace \
  --set cert-manager.enabled=false
```

Get the Data Plane gateway IP (this is different from the Control Plane IP):

```bash
# Wait for Gateway LoadBalancer IP (press Ctrl+C once IP appears)
kubectl get svc gateway-default -n openchoreo-data-plane -w

# Get the gateway IP and convert to nip.io format
DP_IP=$(kubectl get svc gateway-default -n openchoreo-data-plane \
  -o jsonpath='{.status.loadBalancer.ingress[0].ip}' | tr '.' '-')
echo "Data Plane Gateway IP: $DP_IP"
```

Create the DataPlane resource using the gateway IP:

```bash
kubectl apply -f - <<EOF
apiVersion: openchoreo.dev/v1alpha1
kind: DataPlane
metadata:
  name: default
  namespace: default
spec:
  agent:
    enabled: true
  gateway:
    organizationVirtualHost: "openchoreoapis.internal"
    publicVirtualHost: "apps.openchoreo.${DP_IP}.nip.io"
  secretStoreRef:
    name: default
EOF
```

:::note
The Data Plane gateway has its own LoadBalancer IP separate from the Control Plane. nip.io DNS resolves based on the IP in the hostname, so deployed applications must use the gateway IP (not the control plane IP) in their URLs.
:::

</TabItem>
<TabItem value="production" label="Production">

```bash
# Install Data Plane (Gateway API CRDs, kgateway, and GatewayClass are included)
helm install openchoreo-data-plane oci://ghcr.io/openchoreo/helm-charts/openchoreo-data-plane \
  --namespace openchoreo-data-plane --create-namespace \
  --set cert-manager.enabled=false
```

Configure DNS for the gateway:

```bash
# Get gateway LoadBalancer IP/hostname
kubectl get svc gateway-default -n openchoreo-data-plane -w

# Create DNS record: *.apps.openchoreo.${DOMAIN} -> <Gateway LoadBalancer IP/hostname>
```

Create the DataPlane resource:

```bash
kubectl apply -f - <<EOF
apiVersion: openchoreo.dev/v1alpha1
kind: DataPlane
metadata:
  name: default
  namespace: default
spec:
  agent:
    enabled: true
  gateway:
    organizationVirtualHost: "openchoreoapis.internal"
    publicVirtualHost: "apps.openchoreo.${DOMAIN}"
  secretStoreRef:
    name: default
EOF
```

</TabItem>
</Tabs>

**Verify Data Plane:**

```bash
kubectl get pods -n openchoreo-data-plane
# Expected: cluster-agent-*, kgateway-*, external-secrets-*, fluent-bit-* pods

kubectl get dataplane -A
# Expected: default dataplane in Ready state
```

---

## Step 5: Install Build Plane (Optional)

The Build Plane enables OpenChoreo's built-in CI capabilities. Skip this if you only deploy pre-built container images.

<Tabs groupId="install-mode" queryString>
<TabItem value="k3d" label="k3d (Local)" default>

<CodeBlock language="bash">
{`helm install openchoreo-build-plane oci://ghcr.io/openchoreo/helm-charts/openchoreo-build-plane \\
  --version ${versions.helmChart} \\
  --namespace openchoreo-build-plane \\
  --create-namespace \\
  --values https://raw.githubusercontent.com/openchoreo/openchoreo/${versions.githubRef}/install/k3d/single-cluster/values-bp.yaml`}
</CodeBlock>

Register the build plane:

<CodeBlock language="bash">
{`curl -s https://raw.githubusercontent.com/openchoreo/openchoreo/${versions.githubRef}/install/add-build-plane.sh | bash -s -- --control-plane-context k3d-openchoreo`}
</CodeBlock>

</TabItem>
<TabItem value="tryout" label="Try Out">

```bash
helm install openchoreo-build-plane oci://ghcr.io/openchoreo/helm-charts/openchoreo-build-plane \
  --namespace openchoreo-build-plane --create-namespace \
  --set external-secrets.enabled=false \
  --set global.baseDomain=openchoreo.${IP}.nip.io \
  --set registry.ingress.tls.enabled=true \
  --set registry.ingress.annotations."cert-manager\.io/cluster-issuer"=letsencrypt-prod
```

Create BuildPlane resource:

```bash
kubectl apply -f - <<EOF
apiVersion: openchoreo.dev/v1alpha1
kind: BuildPlane
metadata:
  name: default
  namespace: default
spec:
  agent:
    enabled: true
EOF
```

</TabItem>
<TabItem value="production" label="Production">

```bash
# Create DNS record: registry.openchoreo.${DOMAIN} -> <Control Plane LoadBalancer>

helm install openchoreo-build-plane oci://ghcr.io/openchoreo/helm-charts/openchoreo-build-plane \
  --namespace openchoreo-build-plane --create-namespace \
  --set external-secrets.enabled=false \
  --set global.baseDomain=openchoreo.${DOMAIN} \
  --set registry.ingress.tls.enabled=true
```

Create BuildPlane resource:

```bash
kubectl apply -f - <<EOF
apiVersion: openchoreo.dev/v1alpha1
kind: BuildPlane
metadata:
  name: default
  namespace: default
spec:
  agent:
    enabled: true
EOF
```

</TabItem>
</Tabs>

**Verify Build Plane:**

```bash
kubectl get pods -n openchoreo-build-plane
kubectl get buildplane -A
```

---

## Step 6: Install Observability Plane (Optional)

The Observability Plane provides centralized logging and monitoring with OpenSearch.

<Tabs groupId="install-mode" queryString>
<TabItem value="k3d" label="k3d (Local)" default>

**Minimal (Non-HA)** - Uses a single OpenSearch instance:

<CodeBlock language="bash">
{`helm install openchoreo-observability-plane oci://ghcr.io/openchoreo/helm-charts/openchoreo-observability-plane \\
  --version ${versions.helmChart} \\
  --namespace openchoreo-observability-plane \\
  --create-namespace \\
  --values https://raw.githubusercontent.com/openchoreo/openchoreo/${versions.githubRef}/install/k3d/single-cluster/values-op.yaml`}
</CodeBlock>

</TabItem>
<TabItem value="tryout" label="Try Out">

**Minimal (Non-HA)** - Best for evaluation with limited resources:

```bash
helm install openchoreo-observability-plane oci://ghcr.io/openchoreo/helm-charts/openchoreo-observability-plane \
  --namespace openchoreo-observability-plane --create-namespace \
  --set global.installationMode=singleClusterNoHa \
  --set openSearch.enabled=true \
  --set openSearchCluster.enabled=false \
  --timeout 10m
```

</TabItem>
<TabItem value="production" label="Production">

**Production (HA)** - Uses OpenSearch Kubernetes operator with a 3-node cluster:

```bash
# Install OpenSearch operator
helm repo add opensearch-operator https://opensearch-project.github.io/opensearch-k8s-operator/
helm repo update
helm install opensearch-operator opensearch-operator/opensearch-operator \
  --namespace opensearch-operator-system --create-namespace

# Wait for operator
kubectl wait --for=condition=available --timeout=120s deployment/opensearch-operator-controller-manager \
  -n opensearch-operator-system

# Install Observability Plane (HA mode is default)
helm install openchoreo-observability-plane oci://ghcr.io/openchoreo/helm-charts/openchoreo-observability-plane \
  --namespace openchoreo-observability-plane --create-namespace \
  --timeout 10m
```

</TabItem>
</Tabs>

**Configure Observer Integration** (required for logs in Backstage):

```bash
# Configure DataPlane to use observer
kubectl patch dataplane default -n default --type merge -p '{"spec":{"observer":{"url":"http://observer.openchoreo-observability-plane:8080","authentication":{"basicAuth":{"username":"dummy","password":"dummy"}}}}}'

# Configure BuildPlane (if installed)
kubectl patch buildplane default -n default --type merge -p '{"spec":{"observer":{"url":"http://observer.openchoreo-observability-plane:8080","authentication":{"basicAuth":{"username":"dummy","password":"dummy"}}}}}'
```

**Verify Observability Plane:**

```bash
kubectl get pods -n openchoreo-observability-plane
kubectl wait --for=condition=Ready pod --all -n openchoreo-observability-plane --timeout=600s
```

---

## Verification & Access

### Verify All Components

```bash
# Check all planes
kubectl get pods -n openchoreo-control-plane
kubectl get pods -n openchoreo-data-plane
kubectl get pods -n openchoreo-build-plane      # If installed
kubectl get pods -n openchoreo-observability-plane  # If installed

# Check plane resources
kubectl get dataplane,buildplane -A
kubectl get organizations,projects,environments -A
```

### Access URLs

<Tabs groupId="install-mode" queryString>
<TabItem value="k3d" label="k3d (Local)" default>

| Service | URL |
|---------|-----|
| Console (Backstage) | http://openchoreo.localhost:8080 |
| API | http://api.openchoreo.localhost:8080 |
| Deployed Apps | http://`<component>`-`<env>`.openchoreoapis.localhost:9080 |
| Argo Workflows | http://localhost:10081 (if Build Plane installed) |
| OpenSearch Dashboard | http://localhost:11081 (if Observability installed) |

</TabItem>
<TabItem value="tryout" label="Try Out">

| Service | URL |
|---------|-----|
| Console | `https://openchoreo.${IP}.nip.io` |
| API | `https://api.openchoreo.${IP}.nip.io` |
| Identity Server | `https://thunder.openchoreo.${IP}.nip.io` |
| Registry | `https://registry.openchoreo.${IP}.nip.io` (if Build Plane installed) |


</TabItem>
<TabItem value="production" label="Production">

| Service | URL |
|---------|-----|
| Console | `https://openchoreo.${DOMAIN}` |
| API | `https://api.openchoreo.${DOMAIN}` |
| Deployed Apps | `https://<component>-<env>.apps.openchoreo.${DOMAIN}` |
| Registry | `https://registry.openchoreo.${DOMAIN}` (if Build Plane installed) |

</TabItem>
</Tabs>

**Default credentials:** `admin@openchoreo.dev` / `Admin@123`

---

## Next Steps

1. **[Deploy your first component](./deploy-first-component.mdx)** - Get hands-on with OpenChoreo
2. **Explore samples** - Try the <Link to={`https://github.com/openchoreo/openchoreo/tree/${versions.githubRef}/samples`}>sample applications</Link>
3. **Learn concepts** - Understand [OpenChoreo abstractions](../concepts/developer-abstractions.md)

---

## Troubleshooting

### Certificates not issuing (Try Out / Production)

```bash
kubectl describe certificate -n openchoreo-control-plane
kubectl get challenges -A
kubectl describe clusterissuer letsencrypt-prod
```

**Common issues:**
- **"contact email has forbidden domain"**: Use a real email address, not `@example.com`
- **Challenges stuck pending**: Ensure LoadBalancer is publicly accessible for HTTP-01 validation

### Agent not connecting

```bash
# Check agent pods
kubectl get pods -n openchoreo-data-plane -l app.kubernetes.io/name=cluster-agent
kubectl logs -n openchoreo-data-plane -l app.kubernetes.io/name=cluster-agent

# Check cluster-gateway in control plane
kubectl get pods -n openchoreo-control-plane -l app.kubernetes.io/name=cluster-gateway
```

**Common issues:**
- **"connection refused"**: Wait for cluster-gateway to be ready
- **"certificate signed by unknown authority"**: Reinstall the data plane helm release

### Pods stuck in Pending state

```bash
kubectl describe pod <pod-name> -n <namespace>
```

**Common issues:**
- **Insufficient resources**: Scale up nodes or reduce resource requests
- **PVC issues**: Check storage class availability

### Gateway not receiving traffic

```bash
# Check Gateway status
kubectl get gateway -n openchoreo-data-plane
kubectl describe gateway gateway-default -n openchoreo-data-plane

# Check HTTPRoutes
kubectl get httproute -A

# Verify kgateway pods
kubectl get pods -n openchoreo-data-plane -l app.kubernetes.io/name=kgateway
```

---

## Clean Up

<Tabs groupId="install-mode" queryString>
<TabItem value="k3d" label="k3d (Local)" default>

```bash
k3d cluster delete openchoreo
```

</TabItem>
<TabItem value="tryout" label="Try Out">

```bash
# Uninstall OpenChoreo components
helm uninstall openchoreo-observability-plane -n openchoreo-observability-plane 2>/dev/null
helm uninstall openchoreo-build-plane -n openchoreo-build-plane 2>/dev/null
helm uninstall openchoreo-data-plane -n openchoreo-data-plane
helm uninstall openchoreo-control-plane -n openchoreo-control-plane
helm uninstall cert-manager -n cert-manager
```

</TabItem>
<TabItem value="production" label="Production">

```bash
# Uninstall OpenChoreo components
helm uninstall openchoreo-observability-plane -n openchoreo-observability-plane 2>/dev/null
helm uninstall opensearch-operator -n opensearch-operator-system 2>/dev/null
helm uninstall openchoreo-build-plane -n openchoreo-build-plane 2>/dev/null
helm uninstall openchoreo-data-plane -n openchoreo-data-plane
helm uninstall openchoreo-control-plane -n openchoreo-control-plane
helm uninstall cert-manager -n cert-manager 2>/dev/null
```

</TabItem>
</Tabs>
